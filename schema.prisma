generator client {
  provider = "prisma-client-js"
  output   = "./client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id String @id @unique // Discord user id

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime? @updatedAt @map("updated_at")

  justiceSubmissions JusticeSubmission[]
  apiToken           String?             @map("api_token")

  @@map("users")
}

model Member {
  id      String @id // Discord user id
  guildId String @map("guild_id")

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime? @updatedAt @map("updated_at")

  guild Guild @relation(fields: [guildId], references: [id])
  tags  Tag[]

  @@map("members")
}

model Guild {
  id String @unique // Discord guild id

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime? @updatedAt @map("updated_at")

  members Member[]
  tags    Tag[]

  @@map("guilds")
}

model Tag {
  id       Int    @id @default(autoincrement())
  name     String
  content  String
  uses     Int    @default(0)
  guildId  String @map("guild_id")
  memberId String @map("member_id")

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime? @updatedAt @map("updated_at")

  guild  Guild  @relation(fields: [guildId], references: [id])
  author Member @relation(fields: [memberId], references: [id])

  @@unique([name, guildId])
  @@map("tags")
}

model JusticeSubmission {
  id     Int    @id @default(autoincrement())
  userId String @map("member_id")

  type      String  @map("type") // 'xplt' 'dgn' 'appeal'
  targetId  String  @map("target") @db.VarChar(50)
  evidence  String? @map("evidence") @db.VarChar(900)
  notes     String? @map("notes") @db.VarChar(900)
  status    String  @default("Pending Approval") @map("status")
  active    Boolean @default(true)
  messageId String? @map("message_id")

  justiciarVotesFor     String[] @map("justicar_votes_for") // array of user ids
  justiciarVotesAgainst String[] @map("justicar_votes_against")
  juryVotesFor          String[] @map("jury_votes_for")
  juryVotesAgainst      String[] @map("jury_votes_against")

  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime? @updatedAt @map("updated_at")
  // If active is false, then the resolvedAt is required
  resolvedAt DateTime? @map("resolved_at")

  author User @relation(fields: [userId], references: [id])

  @@map("justice_submissions")
}

model Clan {
  robloxGroupId String     @id @map("roblox_group_id")
  name          String  @unique @map("name")
  description   String? @map("description") @db.VarChar(900)
  robloxOwnerId String     @map("roblox_owner_id")
  places        Place[]

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime? @updatedAt @map("updated_at")
}

model Place {
  robloxPlaceId String     @map("roblox_place_id") @unique
  name          String  @map("name")
  description   String? @map("description") @db.VarChar(900)
  clanId        String     @map("clan_id")

  minPlayers  Int?   @map("min_players")
  maxPlayers  Int?   @map("max_players")
  playerRatio String @default("1:1") @map("player_ratio") // defender:raider e.g. 1:3

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime? @updatedAt @map("updated_at")

  clan      Clan       @relation(fields: [clanId], references: [robloxGroupId])
  raidTimes RaidTime[]
}

model RaidTime {
  id Int @id @default(autoincrement())

  startTime String @map("start_time") // Use HH:mm 24 hour format
  endTime   String @map("end_time")
  placeId   String    @map("place_id")

  place Place @relation(fields: [placeId], references: [robloxPlaceId])

  @@map("raid_times")
}